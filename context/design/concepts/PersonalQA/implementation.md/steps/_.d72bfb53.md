---
timestamp: 'Thu Oct 16 2025 22:43:51 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_224351.0a8ebcea.md]]'
content_id: d72bfb538284d290a8089a48fc912a0f6f5d7c7797f0baee00a21aeb40001e4b
---

# TypeScript Implementation with MongoDB

We'll define interfaces that mirror our SSF state declarations, a class for the `PersonalQA` concept that encapsulates the actions, and a MongoDB client for data persistence.

**Modularity and Structure:**

1. `config.ts`: For MongoDB connection string and database name.
2. `errors.ts`: Custom error classes for specific scenarios.
3. `db.ts`: Handles MongoDB connection.
4. `types.ts`: TypeScript interfaces for the concept's data entities.
5. `personalqa.concept.ts`: The core `PersonalQA` concept implementation.
6. `index.ts`: An example usage demonstrating the concept.

***

### 1. `config.ts`

```typescript
// src/config.ts

import * as dotenv from 'dotenv';
dotenv.config();

export const MONGODB_URI: string = process.env.MONGODB_URI || 'mongodb://localhost:27017';
export const DB_NAME: string = process.env.DB_NAME || 'personal_qa_db';
```

### 2. `errors.ts`

```typescript
// src/errors.ts

export class ConceptError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ConceptError';
  }
}

export class FactNotFoundError extends ConceptError {
  constructor(factId: string) {
    super(`Fact with ID '${factId}' not found or does not belong to the user.`);
    this.name = 'FactNotFoundError';
  }
}

export class UnauthorizedError extends ConceptError {
  constructor(message: string = 'Unauthorized access.') {
    super(message);
    this.name = 'UnauthorizedError';
  }
}

export class UserNotFoundError extends ConceptError {
  constructor(userId: string) {
    super(`User with ID '${userId}' not found.`);
    this.name = 'UserNotFoundError';
  }
}
```

### 3. `db.ts`

```typescript
// src/db.ts

import { MongoClient, Db, Collection, ObjectId } from 'mongodb';
import { MONGODB_URI, DB_NAME } from './config';

let client: MongoClient;
let db: Db;

export const connectDB = async (): Promise<void> => {
  if (client && client.connected) {
    console.log('Already connected to MongoDB.');
    return;
  }
  try {
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    db = client.db(DB_NAME);
    console.log('Connected to MongoDB.');
  } catch (error) {
    console.error('Failed to connect to MongoDB', error);
    process.exit(1); // Exit process if DB connection fails
  }
};

export const getDB = (): Db => {
  if (!db) {
    throw new Error('Database not connected. Call connectDB first.');
  }
  return db;
};

export const closeDB = async (): Promise<void> => {
  if (client && client.connected) {
    await client.close();
    console.log('MongoDB connection closed.');
  }
};

// Utility to convert string IDs to ObjectId for MongoDB queries
export const toObjectId = (id: string | ObjectId): ObjectId => {
  if (id instanceof ObjectId) {
    return id;
  }
  return new ObjectId(id);
};
```

### 4. `types.ts`

```typescript
// src/types.ts

import { ObjectId } from 'mongodb';

// Parameter types from the concept specification
export type User = string; // Represents a User ID
export type FactContent = string; // Represents the raw content of a fact
export type Question = string;
export type Answer = string;
export type Time = Date; // Using Date for SSF's DateTime primitive type

// SSF Enumeration for Fact source
export type FactSource = "meal" | "check_in" | "insight" | "behavior";

/**
 * Maps to 'a set of Facts'
 * In MongoDB, this will be the 'facts' collection.
 */
export interface IFact {
  _id?: ObjectId; // MongoDB's default primary key
  owner: User;     // owner User
  at: Time;        // at DateTime
  content: FactContent; // content String
  source: FactSource; // source of "meal" or "check_in" or "insight" or "behavior"
}

/**
 * Maps to 'a set of QAs'
 * In MongoDB, this will be the 'qas' collection.
 */
export interface IQA {
  _id?: ObjectId; // MongoDB's default primary key
  owner: User;     // owner User
  question: Question; // question String
  answer: Answer;  // answer String
  // citedFacts set of Fact: represented as an array of Fact _ids for references
  citedFactIds: ObjectId[];
}
```

### 5. `personalqa.concept.ts`

```typescript
// src/personalqa.concept.ts

import { Collection, ObjectId, FindCursor } from 'mongodb';
import { getDB, toObjectId } from './db';
import { IFact, IQA, User, FactContent, Question, Answer, Time, FactSource } from './types';
import { FactNotFoundError, UnauthorizedError, UserNotFoundError } from './errors';

/**
 * PersonalQA Concept Implementation
 *
 * This class encapsulates the state and actions defined in the PersonalQA concept specification.
 * It interacts with MongoDB to persist the 'Facts' and 'QAs' data, ensuring
 * that each user's data is private and only accessible by its owner.
 */
export class PersonalQA {
  private factsCollection: Collection<IFact>;
  private qasCollection: Collection<IQA>;

  constructor() {
    const db = getDB();
    this.factsCollection = db.collection<IFact>('facts');
    this.qasCollection = db.collection<IQA>('qas');

    // Ensure indexes for efficient querying, especially by owner
    this.factsCollection.createIndex({ owner: 1 });
    this.factsCollection.createIndex({ owner: 1, at: -1 }); // For chronological queries
    this.qasCollection.createIndex({ owner: 1 });
  }

  /**
   * Action: ingestFact
   * Adds a new fact to the owner's private fact base.
   *
   * @param owner The ID of the user who owns this fact.
   * @param at The timestamp when the fact occurred or was recorded.
   * @param content The descriptive content of the fact.
   * @param source The origin of the fact (e.g., "meal", "check_in").
   * @returns The newly created fact object including its ID.
   */
  public async ingestFact(
    owner: User,
    at: Time,
    content: FactContent,
    source: FactSource
  ): Promise<IFact> {
    const newFact: IFact = {
      owner,
      at,
      content,
      source,
    };
    const result = await this.factsCollection.insertOne(newFact);
    if (!result.acknowledged) {
      throw new Error('Failed to ingest fact: MongoDB operation not acknowledged.');
    }
    return { ...newFact, _id: result.insertedId };
  }

  /**
   * Action: forgetFact
   * Removes a specific fact from a user's fact base.
   *
   * @param requester The ID of the user requesting the removal (must be the owner).
   * @param factId The ID of the fact to be removed.
   * @returns True if the fact was successfully deleted, false otherwise.
   * @throws FactNotFoundError if the fact doesn't exist or doesn't belong to the requester.
   */
  public async forgetFact(requester: User, factId: string): Promise<boolean> {
    const objectIdFactId = toObjectId(factId);

    // Requires: fact exists for owner and requester = owner
    const existingFact = await this.factsCollection.findOne({
      _id: objectIdFactId,
      owner: requester,
    });

    if (!existingFact) {
      throw new FactNotFoundError(factId);
    }

    const result = await this.factsCollection.deleteOne({ _id: objectIdFactId, owner: requester });
    return result.deletedCount === 1;
  }

  /**
   * Action: ask
   * Generates an answer to a user's question by citing relevant facts from their private fact base.
   * The question and answer, along with cited facts, are stored as a QA record.
   *
   * @param requester The ID of the user asking the question.
   * @param question The user's question.
   * @returns An object containing the generated answer and the facts cited to form it.
   * @throws UserNotFoundError if the requester is not a valid user (placeholder check).
   */
  public async ask(
    requester: User,
    question: Question
  ): Promise<{ answer: Answer; citedFacts: IFact[] }> {
    // Requires: requester exists (simplified: we assume requester ID is valid if passed)
    if (!requester || typeof requester !== 'string') {
       throw new UserNotFoundError(requester);
    }

    // 1. Retrieve relevant facts for the requester
    const relevantFactsCursor: FindCursor<IFact> = this.factsCollection.find({ owner: requester });
    const allFactsForUser: IFact[] = await relevantFactsCursor.toArray();

    // --- Simplified Answer Derivation Logic (Placeholder for actual AI/NLP) ---
    // In a real system, this would involve NLP, similarity search, LLM calls, etc.
    // For this concept, we'll simulate by finding facts with keywords from the question.
    const questionKeywords = question.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const citedFacts: IFact[] = [];
    let generatedAnswer = `I couldn't find specific information for "${question}" based on your facts.`;

    if (allFactsForUser.length > 0) {
      const matchedFacts: IFact[] = [];
      for (const fact of allFactsForUser) {
        const factContentLower = fact.content.toLowerCase();
        if (questionKeywords.some(keyword => factContentLower.includes(keyword))) {
          matchedFacts.push(fact);
        }
      }

      if (matchedFacts.length > 0) {
        // Simple answer generation: concatenate relevant facts
        generatedAnswer = `Based on your facts, here's what I found:\n` +
                          matchedFacts.map(f => `- ${f.content} (Source: ${f.source}, At: ${f.at.toLocaleDateString()})`).join('\n');
        citedFacts.push(...matchedFacts);
      } else {
         // If no keyword match, provide a general summary if enough facts
         if (allFactsForUser.length > 3) {
           generatedAnswer = `While I don't have a direct answer to "${question}", I see you have recorded ${allFactsForUser.length} facts from sources like ${Array.from(new Set(allFactsForUser.map(f => f.source))).join(', ')}.`;
         }
      }
    } else {
        generatedAnswer = "You haven't recorded any facts yet. Try ingesting some facts first!";
    }
    // --- End of Simplified Answer Derivation Logic ---

    // 2. Store the QA record
    const newQA: IQA = {
      owner: requester,
      question: question,
      answer: generatedAnswer,
      citedFactIds: citedFacts.map(fact => fact._id as ObjectId), // Cast as we know they have _id after retrieval
    };
    await this.qasCollection.insertOne(newQA);

    // 3. Return the answer and cited facts
    return { answer: generatedAnswer, citedFacts };
  }

  // --- Utility methods (not part of concept actions but useful for testing/debugging) ---

  /**
   * Retrieves all facts for a specific owner.
   * @param owner The ID of the user whose facts to retrieve.
   * @returns An array of facts.
   */
  public async getFactsByOwner(owner: User): Promise<IFact[]> {
    return this.factsCollection.find({ owner }).sort({ at: -1 }).toArray();
  }

  /**
   * Retrieves all QAs for a specific owner.
   * @param owner The ID of the user whose QAs to retrieve.
   * @returns An array of QAs.
   */
  public async getQAsByOwner(owner: User): Promise<IQA[]> {
    return this.qasCollection.find({ owner }).sort({ _id: -1 }).toArray();
  }

  /**
   * Deletes all facts and QAs for a specific owner.
   * Useful for cleaning up test data.
   * @param owner The ID of the user whose data to delete.
   * @returns An object with deleted fact count and deleted QA count.
   */
  public async clearUserData(owner: User): Promise<{ factsDeleted: number; qasDeleted: number }> {
    const factsResult = await this.factsCollection.deleteMany({ owner });
    const qasResult = await this.qasCollection.deleteMany({ owner });
    return { factsDeleted: factsResult.deletedCount, qasDeleted: qasResult.deletedCount };
  }
}
```

### 6. `index.ts` (Example Usage)

```typescript
// src/index.ts

import { connectDB, closeDB } from './db';
import { PersonalQA } from './personalqa.concept';
import { FactNotFoundError, UserNotFoundError } from './errors';
import { User, FactContent, Question, Answer, Time, FactSource } from './types';

async function run() {
  await connectDB();
  const personalQA = new PersonalQA();

  const userAlice: User = 'user_alice_123';
  const userBob: User = 'user_bob_456';

  console.log(`--- Testing for ${userAlice} ---`);

  // Clear Alice's previous data for a clean run
  console.log('Clearing Alice\'s data...');
  await personalQA.clearUserData(userAlice);

  // Action: ingestFact
  console.log('\nIngesting facts for Alice...');
  const fact1 = await personalQA.ingestFact(
    userAlice,
    new Date('2023-10-26T19:00:00Z'),
    'late_night + fried linked to lower energy (conf 0.82)',
    'insight'
  );
  console.log('Ingested fact 1:', fact1);

  const fact2 = await personalQA.ingestFact(
    userAlice,
    new Date('2023-10-25T12:30:00Z'),
    'Ate a large pasta meal for lunch.',
    'meal'
  );
  console.log('Ingested fact 2:', fact2);

  const fact3 = await personalQA.ingestFact(
    userAlice,
    new Date('2023-10-27T08:00:00Z'),
    'Felt very energetic after a protein-rich breakfast.',
    'check_in'
  );
  console.log('Ingested fact 3:', fact3);

  console.log('\nAlice\'s facts:');
  const aliceFacts = await personalQA.getFactsByOwner(userAlice);
  aliceFacts.forEach(f => console.log(`- ID: ${f._id}, Content: ${f.content}`));


  // Action: ask
  console.log('\nAlice asks a question about energy...');
  const question1: Question = 'What affects my energy levels?';
  const { answer: ans1, citedFacts: cited1 } = await personalQA.ask(userAlice, question1);
  console.log('Alice\'s Answer 1:', ans1);
  console.log('Cited Facts 1:', cited1.map(f => f.content));

  console.log('\nAlice asks a question about her meals...');
  const question2: Question = 'What did I eat yesterday?';
  const { answer: ans2, citedFacts: cited2 } = await personalQA.ask(userAlice, question2);
  console.log('Alice\'s Answer 2:', ans2);
  console.log('Cited Facts 2:', cited2.map(f => f.content));

  console.log('\nAlice asks a question with no direct match...');
  const question3: Question = 'How much water should I drink?';
  const { answer: ans3, citedFacts: cited3 } = await personalQA.ask(userAlice, question3);
  console.log('Alice\'s Answer 3:', ans3);
  console.log('Cited Facts 3:', cited3.map(f => f.content));


  console.log('\nAlice\'s recorded QAs:');
  const aliceQAs = await personalQA.getQAsByOwner(userAlice);
  aliceQAs.forEach(qa => console.log(`- Q: "${qa.question}" A: "${qa.answer.substring(0, 50)}..."`));


  // Action: forgetFact
  console.log(`\nAlice tries to forget fact with ID: ${fact1._id}`);
  try {
    const deleted = await personalQA.forgetFact(userAlice, fact1._id!.toString());
    console.log(`Fact forgotten successfully: ${deleted}`);
  } catch (error) {
    if (error instanceof FactNotFoundError) {
      console.error(error.message);
    } else {
      console.error('An unexpected error occurred:', error);
    }
  }

  console.log('\nAlice\'s facts after forgetting one:');
  const aliceFactsAfterForget = await personalQA.getFactsByOwner(userAlice);
  aliceFactsAfterForget.forEach(f => console.log(`- ID: ${f._id}, Content: ${f.content}`));

  // Test unauthorized forget
  console.log(`\nBob tries to forget Alice's fact with ID: ${fact2._id}`);
  try {
    await personalQA.forgetFact(userBob, fact2._id!.toString());
    console.log('This should not have happened: Bob deleted Alice\'s fact!');
  } catch (error) {
    if (error instanceof FactNotFoundError) {
      console.error(`Expected error: ${error.message}`);
    } else {
      console.error('An unexpected error occurred:', error);
    }
  }

  console.log('\n--- Testing for Bob ---');
  // Clear Bob's data
  console.log('Clearing Bob\'s data...');
  await personalQA.clearUserData(userBob);

  console.log('\nIngesting facts for Bob...');
  const bobFact1 = await personalQA.ingestFact(
    userBob,
    new Date('2023-10-20T07:00:00Z'),
    'Often feel sluggish after heavy breakfast.',
    'check_in'
  );
  console.log('Ingested fact for Bob:', bobFact1);

  console.log('\nBob asks a question...');
  const bobQuestion1: Question = 'Why do I feel sluggish?';
  const { answer: bobAns1, citedFacts: bobCited1 } = await personalQA.ask(userBob, bobQuestion1);
  console.log('Bob\'s Answer:', bobAns1);
  console.log('Cited Facts:', bobCited1.map(f => f.content));

  await closeDB();
}

run().catch(console.error);
```

***

### Instructions to Run:

1. **Set up your environment:**
   * Make sure you have Node.js and npm/yarn installed.
   * Ensure a MongoDB instance is running (e.g., locally or via MongoDB Atlas).

2. **Create Project:**
   ```bash
   mkdir personal-qa-concept
   cd personal-qa-concept
   npm init -y
   mkdir src
   ```

3. **Install Dependencies:**
   ```bash
   npm install mongodb dotenv
   npm install -D typescript @types/node @types/mongodb ts-node
   ```

4. **Create `tsconfig.json`:**
   ```json
   {
     "compilerOptions": {
       "target": "es2020",
       "module": "commonjs",
       "strict": true,
       "esModuleInterop": true,
       "skipLibCheck": true,
       "forceConsistentCasingInFileNames": true,
       "outDir": "./dist",
       "rootDir": "./src"
     },
     "include": ["src/**/*.ts"],
     "exclude": ["node_modules"]
   }
   ```

5. **Create `.env` file:**
   In the root of your project, create a file named `.env` and add your MongoDB connection string.
   ```
   MONGODB_URI=mongodb://localhost:27017
   DB_NAME=personal_qa_db
   ```
   (Adjust `MONGODB_URI` if your MongoDB is not running locally or requires authentication).

6. **Place the TypeScript files:**
   Copy the `config.ts`, `errors.ts`, `db.ts`, `types.ts`, `personalqa.concept.ts`, and `index.ts` files into the `src/` directory.

7. **Run the application:**
   ```bash
   npx ts-node src/index.ts
   ```

This will connect to MongoDB, perform the actions for Alice and Bob, print the results to the console, and demonstrate the multi-user separation and fact management. You can then inspect your `personal_qa_db` database in MongoDB to see the `facts` and `qas` collections.
