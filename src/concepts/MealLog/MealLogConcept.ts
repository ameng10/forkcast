// --- Required Imports ---
import { Collection, Document, MongoClient, WithId } from "mongodb"; // MongoDB driver
import { Empty, ID } from "@utils/types.ts";

// Minimal database interface used when instantiated with a Db from the server
interface MinimalDb {
  collection<T extends Document = Document>(name: string): Collection<T>;
  databaseName?: string;
  name?: string;
}

// --- Generic Type Definitions ---
// These interfaces define the minimal structure required for generic User and FoodItem types.
// In a real application, these would be richer interfaces or classes managed by other concepts.
// We assume User has a unique 'id' for comparison purposes.
type UserId = ID;

interface User {
  id: UserId;
  // Add other relevant user properties here, e.g., name: string;
}

// For FoodItem, we assume it's an object with an ID and perhaps other properties
// that we want to embed directly into the meal document for a denormalized collection.
interface FoodItem {
  id: string; // Unique ID for the food item (e.g., from a central food database)
  name: string; // The display name of the food item
  // You can add more properties here if they are part of the FoodItem concept,
  // e.g., calories: number, category: string, etc.
}

// --- State Modeling Language Enums and Errors ---

export enum MealStatus {
  ACTIVE = "active",
  DELETED = "deleted",
}

/**
 * Custom Error class for permission-related failures.
 */
export class PermissionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PermissionError";
  }
}

// --- MongoDB Document Structure ---
// This interface defines how a Meal document is stored in MongoDB.
// It uses `ownerId` to reference a User, and embeds `FoodItem` objects directly.
export interface MealDocument {
  _id: string; // MongoDB's unique ID for the meal, typically a UUID generated by the app.
  ownerId: UserId; // The ID of the user who owns this meal.
  at: Date; // The date and time the meal was consumed.
  items: FoodItem[]; // An array of embedded FoodItem objects.
  notes?: string; // Optional notes for the meal.
  status: MealStatus; // The current status of the meal (active/deleted).
}

// --- Meal Class (In-memory representation of a Meal) ---
/**
 * Represents a single meal entry within the MealLog concept.
 * It is generic over the User and FoodItem types, hydrating `ownerId` into a `User` object.
 */
class Meal<U extends User, F extends FoodItem> {
  public readonly id: string; // Unique identifier for the meal (UUID)
  public readonly owner: U;
  public at: Date;
  public items: F[];
  public notes?: string;
  public status: MealStatus;

  /**
   * Private constructor to enforce creation via static factory methods
   * (e.g., `createNewMeal`) or controlled instantiation (e.g., `fromDocument`).
   */
  private constructor(
    id: string,
    owner: U,
    at: Date,
    items: F[],
    status: MealStatus,
    notes?: string,
  ) {
    this.id = id;
    this.owner = owner;
    this.at = at;
    this.items = items;
    this.notes = notes;
    this.status = status;
  }

  /**
   * Factory method for creating a new Meal based on concept's `submit` action parameters.
   * This handles initial status and ID generation.
   * @param owner The user who owns this meal.
   * @param at The date and time the meal was consumed.
   * @param items An array of food items included in the meal.
   * @param notes Optional notes for the meal.
   * @returns A new `Meal` instance.
   * @throws Error if owner is invalid or items is empty.
   */
  public static createNewMeal<U extends User, F extends FoodItem>(
    owner: U,
    at: Date,
    items: F[],
    notes?: string,
  ): Meal<U, F> {
    if (!owner || !owner.id) {
      throw new Error(
        "Meal owner cannot be undefined or null and must have an ID.",
      );
    }
    if (!items || items.length === 0) {
      throw new Error("A meal must contain at least one food item.");
    }
    // Generate a unique ID for the meal (e.g., using Node.js's crypto module or a UUID library).
    const newMealId = crypto.randomUUID();
    return new Meal(newMealId, owner, at, items, MealStatus.ACTIVE, notes);
  }

  /**
   * Factory method for hydrating a Meal object from a MongoDB document.
   * @param doc The MongoDB document to convert.
   * @param owner The hydrated User object corresponding to `doc.ownerId`.
   * @returns A `Meal` instance.
   */
  public static fromDocument<U extends User, F extends FoodItem>(
    doc: WithId<MealDocument>,
    owner: U,
  ): Meal<U, F> {
    return new Meal(
      doc._id,
      owner,
      doc.at,
      doc.items as F[], // Type assertion for generic FoodItem
      doc.status,
      doc.notes,
    );
  }

  /**
   * Converts the current Meal object into a MongoDB document structure for storage.
   * @returns A `MealDocument` representation of the meal.
   */
  public toDocument(): MealDocument {
    return {
      _id: this.id,
      ownerId: this.owner.id,
      at: this.at,
      items: this.items,
      notes: this.notes,
      status: this.status,
    };
  }

  /**
   * Provides a string representation for debugging and logging.
   */
  public toString(): string {
    return (
      `Meal(ID=${this.id.substring(0, 8)}..., OwnerID=${this.owner.id}, ` +
      `Time=${this.at.toISOString()}, Status=${this.status})`
    );
  }
}

// --- MealLog Concept Implementation ---
/**
 * Concept: MealLog [User, FoodItem]
 *
 * Purpose: Capture meals quickly with minimal friction.
 *
 * Principle: A user records a meal with time, items, and an optional note;
 *            meals can be edited or deleted. This concept stores facts only.
 *
 * This class implements the MealLog concept, managing a collection of Meal objects
 * persisted in MongoDB. It ensures that actions adhere to the defined requirements and effects.
 */
export class MealLogConcept<U extends User, F extends FoodItem> {
  private dbClient?: MongoClient;
  private dbFromServer?: MinimalDb;
  private ownsClient = false;
  private dbName: string;
  private mealsCollection?: Collection<MealDocument>;
  // A resolver function to fetch a full User object given a UserId.
  // This maintains the independence of the MealLog concept from the User concept's implementation.
  private userResolver: (userId: UserId) => Promise<U | undefined>;

  /**
   * Initializes the MealLog concept.
   * @param mongoUri The MongoDB connection URI (e.g., "mongodb://localhost:27017").
   * @param dbName The name of the database to use.
   * @param userResolver An asynchronous function to retrieve a User object by its ID.
   */
  // Overload 1: Standard constructor used in tests (client or URI string)
  constructor(
    mongo: string | MongoClient,
    dbName: string,
    userResolver: (userId: UserId) => Promise<U | undefined>,
  );
  // Overload 2: Adapter constructor used by concept_server (Db only)
  constructor(db: MinimalDb);
  // Implementation
  constructor(
    mongoOrDb: string | MongoClient | MinimalDb,
    dbName?: string,
    userResolver?: (userId: UserId) => Promise<U | undefined>,
  ) {
    if (typeof mongoOrDb === "string") {
      this.dbClient = new MongoClient(mongoOrDb);
      this.ownsClient = true;
      this.dbName = dbName!;
    } else if (mongoOrDb instanceof MongoClient) {
      this.dbClient = mongoOrDb;
      this.dbName = dbName!;
    } else {
      // Received a Db from the concept server
      this.dbFromServer = mongoOrDb;
      this.dbName = mongoOrDb.databaseName ?? mongoOrDb.name ?? "";
    }

    // If no resolver provided (server path), use a permissive default that hydrates minimal user shape
    this.userResolver = userResolver ??
      ((userId: UserId) => Promise.resolve({ id: userId } as unknown as U));
  }

  /**
   * Establishes the connection to MongoDB and sets up the collection.
   * Must be called before any other database operations.
   */
  public async connect(): Promise<Empty> {
    if (this.dbFromServer) {
      // Server provided Db; treat as already connected
      this.mealsCollection = this.dbFromServer.collection<MealDocument>(
        "Meals",
      );
      return {};
    }
    if (this.dbClient) {
      if (this.ownsClient) {
        await this.dbClient.connect();
      }
      this.mealsCollection = this.dbClient.db(this.dbName).collection<
        MealDocument
      >("Meals");
    } else {
      throw new Error("No database available to connect.");
    }
    return {};
  }

  /**
   * Closes the MongoDB connection.
   */
  public async disconnect(): Promise<Empty> {
    if (this.dbFromServer) {
      // Do not close external server-managed connections
      this.mealsCollection = undefined;
      return {};
    }
    if (this.dbClient && this.ownsClient) {
      await this.dbClient.close();
    }
    this.mealsCollection = undefined;
    return {};
  }

  #collection(): Collection<MealDocument> {
    // Lazily initialize when provided a Db directly (server-managed)
    if (!this.mealsCollection && this.dbFromServer) {
      this.mealsCollection = this.dbFromServer.collection<MealDocument>(
        "Meals",
      );
    }
    if (!this.mealsCollection) {
      throw new Error("MealLogConcept is not connected. Call connect() first.");
    }
    return this.mealsCollection;
  }

  // Exposed for API: return a JSON-friendly description, not the raw collection object
  public getCollection(): { name: string } {
    const col = this.#collection();
    // @ts-ignore - driver provides 'collectionName'
    const name =
      (col as unknown as { collectionName?: string }).collectionName ?? "Meals";
    return { name };
  }

  /**
   * Internal helper to retrieve a raw Meal document from MongoDB by its ID.
   * @param mealId The unique ID of the meal.
   * @returns The MongoDB document if found, otherwise null.
   */
  // Overloads: support API-style object or positional string
  async #getMealDocumentById(
    mealId: string,
  ): Promise<WithId<MealDocument> | null>;
  async #getMealDocumentById(
    args: { mealId: string },
  ): Promise<WithId<MealDocument> | null>;
  async #getMealDocumentById(
    mealIdOrArgs: string | { mealId: string },
  ): Promise<WithId<MealDocument> | null> {
    const mealId = typeof mealIdOrArgs === "string"
      ? mealIdOrArgs
      : mealIdOrArgs.mealId;
    const collection = this.#collection();
    const result = await collection.findOne({ _id: mealId });
    return result;
  }

  /**
   * Internal helper to retrieve a fully hydrated `Meal` object from MongoDB by its ID.
   * This involves fetching the document and then resolving the `User` object.
   * @param mealId The unique ID of the meal.
   * @returns The `Meal` object if found and owner resolved, otherwise undefined.
   */
  async #getMealObjectById(
    mealId: string,
  ): Promise<Meal<U, F> | undefined>;
  async #getMealObjectById(
    args: { mealId: string },
  ): Promise<Meal<U, F> | undefined>;
  async #getMealObjectById(
    mealIdOrArgs: string | { mealId: string },
  ): Promise<Meal<U, F> | undefined> {
    const mealId = typeof mealIdOrArgs === "string"
      ? mealIdOrArgs
      : mealIdOrArgs.mealId;
    const doc = await this.#getMealDocumentById(mealId);
    if (!doc) return undefined;

    const owner = await this.userResolver(doc.ownerId);
    if (!owner) {
      // Data inconsistency: ownerId in meal document refers to a non-existent user.
      console.error(
        `Owner with ID ${doc.ownerId} not found for meal ${mealId}. Skipping hydration.`,
      );
      return undefined;
    }
    return Meal.fromDocument(doc, owner);
  }

  // --- Actions ---

  /**
   * Action: submit
   * Purpose: Records a new meal entry.
   *
   * @param owner The user submitting the meal.
   * @param at The time the meal was consumed.
   * @param items An array of food items in the meal.
   * @param notes Optional notes for the meal.
   * @returns The newly created `Meal` object.
   *
   * Requires:
   * - `owner` is a valid `User` object (not undefined/null, has an `id`).
   * - `items` is nonempty.
   *
   * Effects:
   * - Creates a new `Meal` instance with status `ACTIVE`.
   * - Inserts the new meal's document into the MongoDB `Meals` collection.
   *
   * Throws:
   * - Error: If `owner` is invalid or `items` is empty.
   */
  // Overloads: positional (tests) and object (API)
  public async submit(
    owner: U,
    at: Date,
    items: F[],
    notes?: string,
  ): Promise<Meal<U, F>>;
  public async submit(
    args: {
      owner?: U;
      ownerId?: UserId;
      at: Date | string;
      items: F[];
      notes?: string;
    },
  ): Promise<Meal<U, F>>;
  public async submit(
    ownerOrArgs: U | {
      owner?: U;
      ownerId?: UserId;
      at: Date | string;
      items: F[];
      notes?: string;
    },
    at?: Date,
    items?: F[],
    notes?: string,
  ): Promise<Meal<U, F>> {
    let owner: U;
    let atDate: Date;
    let theItems: F[];
    let theNotes: string | undefined;

    if (
      typeof ownerOrArgs === "object" && "items" in ownerOrArgs &&
      (at === undefined)
    ) {
      const args = ownerOrArgs as {
        owner?: U;
        ownerId?: UserId;
        at: Date | string;
        items: F[];
        notes?: string;
      };
      owner = args.owner ?? (await this.userResolver(args.ownerId as UserId))!;
      atDate = args.at instanceof Date ? args.at : new Date(args.at);
      theItems = args.items;
      theNotes = args.notes;
    } else {
      owner = ownerOrArgs as U;
      atDate = at as Date;
      theItems = items as F[];
      theNotes = notes;
    }

    const newMeal = Meal.createNewMeal(owner, atDate, theItems, theNotes);
    const mealDoc = newMeal.toDocument();
    const collection = this.#collection();
    await collection.insertOne(mealDoc);
    return newMeal;
  }

  /**
   * Action: edit
   * Purpose: Modifies an existing meal entry.
   *
   * @param caller The user attempting to edit the meal.
   * @param mealId The unique ID of the meal to be edited.
   * @param items Optional new array of food items.
   * @param notes Optional new notes string.
   * @returns A Promise that resolves when the meal is successfully edited.
   *
   * Requires:
   * - `mealId` refers to an existing `Meal` document.
   * - `caller` is the owner of the `meal` (compared by `id`).
   * - `meal` status is `ACTIVE`.
   * - If `items` is provided, it must be nonempty.
   *
   * Effects:
   * - Updates the `items` and/or `notes` fields of the `Meal` document in MongoDB.
   *
   * Throws:
   * - Error: If the meal does not exist, is not active, or updated items are empty.
   * - PermissionError: If `caller` is not the owner of the meal.
   */
  public async edit(
    caller: U,
    mealId: string,
    items?: F[],
    notes?: string,
  ): Promise<void>;
  public async edit(
    args: {
      caller?: U;
      callerId?: UserId;
      mealId: string;
      items?: F[];
      notes?: string;
      at?: Date | string;
    },
  ): Promise<Empty | { error: string }>;
  public async edit(
    callerOrArgs: U | {
      caller?: U;
      callerId?: UserId;
      mealId: string;
      items?: F[];
      notes?: string;
      at?: Date | string;
    },
    mealId?: string,
    items?: F[],
    notes?: string,
  ): Promise<void | (Empty | { error: string })> {
    let caller: U;
    let id: string;
    let newItems: F[] | undefined = items;
    let newNotes: string | undefined = notes;
    const isObjectForm = typeof callerOrArgs === "object" &&
      mealId === undefined;
    let newAt: Date | undefined;

    if (isObjectForm) {
      const args = callerOrArgs as {
        caller?: U;
        callerId?: UserId;
        mealId: string;
        items?: F[];
        notes?: string;
        at?: Date | string;
      };
      caller = args.caller ??
        (await this.userResolver(args.callerId as UserId))!;
      id = args.mealId;
      newItems = args.items;
      newNotes = args.notes;
      if (args.at !== undefined) {
        const parsed = args.at instanceof Date ? args.at : new Date(args.at);
        if (isNaN(parsed.getTime())) {
          return { error: "Invalid 'at' timestamp. Use ISO-8601 or Date." };
        }
        newAt = parsed;
      }
    } else {
      caller = callerOrArgs as U;
      id = mealId as string;
    }
    // Requirements check
    const collection = this.#collection();
    const mealDoc = await this.#getMealDocumentById(id);
    if (!mealDoc) {
      if (isObjectForm) {
        return { error: `Meal with ID '${id}' does not exist.` };
      }
      throw new Error(`Meal with ID '${id}' does not exist.`);
    }
    // Compare users by their unique ID
    if (mealDoc.ownerId !== caller.id) {
      if (isObjectForm) {
        return { error: "Caller is not the owner of this meal." };
      }
      throw new PermissionError("Caller is not the owner of this meal.");
    }
    if (mealDoc.status !== MealStatus.ACTIVE) {
      const msg =
        `Cannot edit a meal that is not active. Current status: ${mealDoc.status}`;
      if (isObjectForm) return { error: msg };
      throw new Error(msg);
    }
    if (newItems !== undefined && newItems.length === 0) {
      const msg = "Items array cannot be empty when updating.";
      if (isObjectForm) return { error: msg };
      throw new Error(msg);
    }

    // Effects
    const updateFields: Partial<MealDocument> = {};
    if (newItems !== undefined) {
      updateFields.items = newItems;
    }
    if (newNotes !== undefined) {
      updateFields.notes = newNotes;
    }
    if (newAt !== undefined) {
      updateFields.at = newAt;
    }

    if (Object.keys(updateFields).length > 0) {
      await collection.updateOne(
        { _id: id },
        { $set: updateFields },
      );
    }
    if (isObjectForm) return {};
  }

  /**
   * Action: delete
   * Purpose: Marks a meal entry as deleted.
   *
   * @param caller The user attempting to delete the meal.
   * @param mealId The unique ID of the meal to be deleted.
   * @returns A Promise that resolves when the meal status is successfully updated.
   *
   * Requires:
   * - `mealId` refers to an existing `Meal` document.
   * - `caller` is the owner of the `meal` (compared by `id`).
   * - `meal` status is `ACTIVE`.
   *
   * Effects:
   * - Sets the `status` of the `Meal` document to `DELETED` in MongoDB.
   *
   * Throws:
   * - Error: If the meal does not exist or is not active.
   * - PermissionError: If `caller` is not the owner of the meal.
   */
  public async delete(caller: U, mealId: string): Promise<void>;
  public async delete(
    args: { caller?: U; callerId?: UserId; mealId: string },
  ): Promise<Empty | { error: string }>;
  public async delete(
    callerOrArgs: U | { caller?: U; callerId?: UserId; mealId: string },
    mealId?: string,
  ): Promise<void | (Empty | { error: string })> {
    let caller: U;
    let id: string;
    const isObjectForm = typeof callerOrArgs === "object" &&
      mealId === undefined;
    if (isObjectForm) {
      const args = callerOrArgs as {
        caller?: U;
        callerId?: UserId;
        mealId: string;
      };
      caller = args.caller ??
        (await this.userResolver(args.callerId as UserId))!;
      id = args.mealId;
    } else {
      caller = callerOrArgs as U;
      id = mealId as string;
    }
    // Requirements check
    const collection = this.#collection();
    const mealDoc = await this.#getMealDocumentById(id);
    if (!mealDoc) {
      if (isObjectForm) {
        return { error: `Meal with ID '${id}' does not exist.` };
      }
      throw new Error(`Meal with ID '${id}' does not exist.`);
    }
    // Compare users by their unique ID
    if (mealDoc.ownerId !== caller.id) {
      if (isObjectForm) {
        return { error: "Caller is not the owner of this meal." };
      }
      throw new PermissionError("Caller is not the owner of this meal.");
    }
    if (mealDoc.status !== MealStatus.ACTIVE) {
      const msg =
        `Cannot delete a meal that is not active. Current status: ${mealDoc.status}`;
      if (isObjectForm) return { error: msg };
      throw new Error(msg);
    }

    // Effects
    await collection.updateOne(
      { _id: id },
      { $set: { status: MealStatus.DELETED } },
    );
    if (isObjectForm) return {};
  }

  // --- Utility Methods (not formal actions, but helpful for concept interaction) ---

  /**
   * Retrieves meals associated with a specific owner.
   * @param ownerId The ID of the user whose meals are to be retrieved.
   * @param includeDeleted If true, includes meals marked as deleted; otherwise, only active meals.
   * @returns A Promise that resolves to an array of Meal objects owned by the specified user.
   */
  public async getMealsForOwner(
    ownerId: UserId,
    includeDeleted?: boolean,
  ): Promise<Meal<U, F>[]>;
  public async getMealsForOwner(
    args: { ownerId: UserId; includeDeleted?: boolean },
  ): Promise<Meal<U, F>[]>;
  public async getMealsForOwner(
    ownerOrArgs: UserId | { ownerId: UserId; includeDeleted?: boolean },
    includeDeleted: boolean = false,
  ): Promise<Meal<U, F>[]> {
    const ownerId = typeof ownerOrArgs === "string"
      ? ownerOrArgs
      : ownerOrArgs.ownerId;
    includeDeleted = typeof ownerOrArgs === "string"
      ? includeDeleted
      : (ownerOrArgs.includeDeleted ?? false);
    const query: Document = { ownerId: ownerId };
    if (!includeDeleted) {
      query.status = MealStatus.ACTIVE;
    }

    const collection = this.#collection();
    const mealDocs = await collection.find(query).toArray();
    const meals: Meal<U, F>[] = [];

    // For each meal document, try to resolve the owner and construct the Meal object
    for (const doc of mealDocs) {
      const owner = await this.userResolver(doc.ownerId);
      if (owner) {
        meals.push(Meal.fromDocument(doc, owner));
      } else {
        console.warn(
          `Owner with ID ${doc.ownerId} not found for meal ${doc._id}. Skipping meal.`,
        );
      }
    }
    return meals;
  }

  /**
   * Retrieves a meal by its unique ID.
   * @param mealId The unique ID of the meal to retrieve.
   * @param callerId Optional. If provided, enforces that the caller is the owner of the meal.
   *                 This helps restrict read access to user's own logs.
   * @returns A Promise that resolves to the Meal object if found, otherwise undefined.
   * @throws PermissionError if `callerId` is provided and does not match the meal's owner.
   */
  public async getMealById(
    mealId: string,
    callerId?: UserId,
  ): Promise<Meal<U, F> | undefined>;
  public async getMealById(
    args: { mealId: string; callerId?: UserId },
  ): Promise<Meal<U, F> | { error: string } | undefined>;
  public async getMealById(
    mealOrArgs: string | { mealId: string; callerId?: UserId },
    callerId?: UserId,
  ): Promise<Meal<U, F> | { error: string } | undefined> {
    const mealId = typeof mealOrArgs === "string"
      ? mealOrArgs
      : mealOrArgs.mealId;
    callerId = typeof mealOrArgs === "string" ? callerId : mealOrArgs.callerId;
    const meal = await this.#getMealObjectById(mealId);
    if (meal && callerId && meal.owner.id !== callerId) {
      // If a callerId is provided, and it doesn't match the owner, deny access.
      // This implements the implied "only the user will be able to access their own meal logs" for read operations.
      if (typeof mealOrArgs === "string") {
        throw new PermissionError(
          "Caller is not authorized to view this meal.",
        );
      } else {
        return { error: "Caller is not authorized to view this meal." };
      }
    }
    return meal;
  }
}

// Export for test usage
export default MealLogConcept;
