# Project Reflection

## Overview
- Overall: challenging but educational — strong gains in design and API thinking, harder in implementation and context management.
- Conceptual work was straightforward; turning ideas into stable code was the main difficulty.

## What went well
- Idea and concept creation: quick and productive; clear separation of concepts helped planning.
- Learned core patterns for web service creation and app structure.
- Improved prompt engineering skills for interacting with coding assistants.

## Challenges
- Implementation complexity: integrating pieces, wiring APIs, and edge-case handling were time-consuming.
- Context fragmentation: relevant files and references were scattered, making comprehension and updates slow.
- Debugging multi-file flows was inefficient without good context navigation.

## Mistakes and how I’d avoid them
- Mistake: Poor linking between local code and Context tool notes — led to stale or misplaced references.
  - Fix: Maintain a single canonical index, annotate code with clear TODOs, and sync context entries immediately.
- Mistake: Overreliance on the agentic tool for large refactors without manual verification.
  - Fix: Do smaller, verifiable commits and pair tool suggestions with manual reviews and tests.

## Skills gained and ones to develop
- Gained: web service creation, app architecture, API design basics, and prompt engineering.
- Need to develop: large-scale debugging, automated test design, and better context-management workflows.

## Use of the Context tool
- Used to store and retrieve design notes, API specs, and code snippets.
- Pain points: required switching windows, awkward prompting, and difficult code navigation when updating context.
- Would improve by consolidating context, using explicit anchors, and keeping smaller focused entries.

## Use of an agentic coding tool
- Used for scaffolding, generating code snippets, and faster iterations on routine tasks.
- Limitations: struggled with locating exact context in a large codebase and produced brittle fixes without tests.

## Conclusions about LLMs in software development
- LLMs are excellent at ideation, scaffolding, and repetitive code generation.
- They currently fall short as full substitutes for human judgment in debugging, context-aware refactors, and complex integration work.
- Best role: accelerate routine tasks and augment developer productivity while humans retain design, verification, and integration responsibilities.
- Aim for a hybrid workflow: combine LLM suggestions with strict review, tests, and explicit context management.
